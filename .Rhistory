sigma <- 165.5 # 2
# define and generate the original data set
def <- defData(varname = "age", dist = "normal", formula = 32.7, variance = 9.6, id = "id")
def <- defData(varname = "gender", dist = "binary", formula = 0.6)
def <- defData(varname = "weight", dist = "normal", formula = 50, variance = 8.6, id = "id")
def <- defData(varname = "marital_status", formula = "0.1;0.3;0.4;0.2", dist = "categorical", id = "id")
def <- defData(varname = "WHO_stage", dist = "normal", formula = "0.2;0.15;0.55;0.1", dist = "categorical", id = "id")
def <- defData(varname = "WHO_stage", formula = "0.2;0.15;0.55;0.1", dist = "categorical", id = "id")
dt <- genData(n, def)
View(dt)
set.seed(1234567)
n <- 200
tp <- 7 # 7
rho <- 0.7 # 0.8
#mu <- abs(rnorm(tp, 2, 1))
mu <- 320
sigma <- 165.5 # 2
# define and generate the original data set
def <- defData(varname = "age", dist = "normal", formula = 32.7, variance = 9.6, id = "id")
def <- defData(def, varname = "gender", dist = "binary", formula = 0.6)
def <- defData(def, varname = "weight", dist = "normal", formula = 50, variance = 8.6, id = "id")
def <- defData(def, varname = "marital_status", formula = "0.1;0.3;0.4;0.2", dist = "categorical", id = "id")
def <- defData(def, varname = "WHO_stage", formula = "0.2;0.15;0.55;0.1", dist = "categorical", id = "id")
dt <- genData(n, def)
View(dt)
# Generate column names based on tp (time points) value
cnames <- paste0("y", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- addCorData(dt, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(comp_sym)
View(comp_sym)
dtWide <- genCorData(n, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
# Simulations of longitudinal data using user defined correlation matrices i.e. not using covariance structures from the simstudy package
library(simstudy)
library(psych)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(purrr)
library(Matrix)
library(MASS)
dtWide <- genCorData(n, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
# Generate column names based on tp (time points) value
cnames <- paste0("y", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- genCorData(n, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
abs(rnorm(tp, 2, 1))
mu <- abs(rnorm(tp, 320, 165.5))
genCorData(n, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(dtWide)
mu
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "y")
View(dtLong)
dtLong <- subset(dtLong, select = -timeID)
# Fit a fixed effects model (without controlling for random effects)
fxd <- lm(y ~ period, data = dtLong)
summary(fxd)
fit <- gls(y ~ period, data = dtLong)
summary(fit)
library(nlme)
fit <- gls(y ~ period, data = dtLong)
summary(fit)
ACF.fit <- ACF(fit, form = ~ 1 | id)
#ACF.fit <- ACF(fit, maxLag = 15)
plot(ACF.fit)
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(dtWide)
mu <- abs(rnorm(tp, 320, 165.5))
sigma <- 75 # 2
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
mu <- abs(rnorm(tp, 320, 150))
sigma <- 75 # 2
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
# Ensure that CD4 counts are not below 50
dtWide <- dtWide %>%
mutate(across(starts_with("CD4"), ~ pmax(., 0)))
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "CD4")
dtLong <- subset(dtLong, select = -timeID)
write.csv(dtLong, file = "csdata.csv")
getwd()
# Fit a fixed effects model (without controlling for random effects)
fxd <- lm(CD4 ~ period, data = dtLong)
summary(fxd)
# Simulations of longitudinal data using user defined correlation matrices i.e. not using covariance structures from the simstudy package
library(simstudy)
library(psych)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(purrr)
library(Matrix)
library(MASS)
library(nlme)
set.seed(1234567)
n <- 200
tp <- 7 # 7
rho <- 0.7 # 0.8
mu <- abs(rnorm(tp, 320, 100))
sigma <- 25 # 2
# define and generate the original data set
def <- defData(varname = "age", dist = "normal", formula = 32.7, variance = 9.6, id = "id")
def <- defData(def, varname = "gender", dist = "binary", formula = 0.6)
def <- defData(def, varname = "weight", dist = "normal", formula = 50, variance = 8.6, id = "id")
def <- defData(def, varname = "marital_status", formula = "0.1;0.3;0.4;0.2", dist = "categorical", id = "id")
def <- defData(def, varname = "WHO_stage", formula = "0.2;0.15;0.55;0.1", dist = "categorical", id = "id")
dt <- genData(n, def)
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(dtWide)
summary(dtWide)
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "CD4")
dtLong <- subset(dtLong, select = -timeID)
write.csv(dtLong, file = "csdata.csv")
# Fit a fixed effects model (without controlling for random effects)
fxd <- lm(CD4 ~ period, data = dtLong)
summary(fxd)
# Extract residuals
dtResidL <- subset(dtLong, select = c("id", "period"))
View(dtResidL)
dtResidL$residuals <- fxd$residuals
dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
View(dtResidW)
# Create covariance matrices
resCov <- cov(dtResidW[, -1])
# Create correlation matrices
resCor <- cor(dtResidW[, -1])
View(resCor)
# Create a list of vectors from the matrix
listCor <- map(-(ncol(resCor) - 1):(ncol(resCor) - 1), ~ mean(resCor[outer(1:ncol(resCor), 1:ncol(resCor), "-") == .x]))
# Create a data frame from listCor
lag <- 1:(tp-1)
means <- unlist(listCor[1:(tp-1)])
dat2 <- data.frame(lag, means = rev(means))
# Plot line graph using the mean for each lag in the list
ggplot(dat2, aes(x = lag, y = means)) +
geom_line() +
scale_x_continuous(breaks = lag) +
ylim(c(0,1)) +
ggtitle("Compound Symmetry") +
xlab("Lag") +
ylab("Mean") +
theme_bw()
shiny::runApp('~/RShiny/LMMCov/LMMCov_v002')
runApp('~/RShiny/LMMCov/LMMCov_v002')
runApp('~/RShiny/LMMCov/LMMCov_v002')
runApp('~/RShiny/LMMCov/LMMCov_v002')
fit <- gls(y ~ period, data = dtLong)
dtResidL$residuals <- fit$residuals
dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
fit <- gls(CD4 ~ period, data = dtLong)
summary(fit)
dtResidL$residuals <- fit$residuals
dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
View(dtResidW)
# Create correlation matrices
resCor <- cor(dtResidW[, -1])
View(resCor)
# Create a list of vectors from the matrix
listCor <- map(-(ncol(resCor) - 1):(ncol(resCor) - 1), ~ mean(resCor[outer(1:ncol(resCor), 1:ncol(resCor), "-") == .x]))
# Create a data frame from listCor
lag <- 1:(tp-1)
means <- unlist(listCor[1:(tp-1)])
dat2 <- data.frame(lag, means = rev(means))
# Plot line graph using the mean for each lag in the list
ggplot(dat2, aes(x = lag, y = means)) +
geom_line() +
scale_x_continuous(breaks = lag) +
ylim(c(0,1)) +
ggtitle("Compound Symmetry") +
xlab("Lag") +
ylab("Mean") +
theme_bw()
load("~/RShiny/LMMCov/LMMCov_v002/covid.RData")
View(covid)
names(covid)
fit <- gls(oxygen_sats ~ time, data = covid)
summary(fit)
dtResidL <- subset(dtLong, select = c("hospital_number", "time"))
dtResidL <- subset(covid, select = c("hospital_number", "time"))
dtResidL$residuals <- fit$residuals
View(dtResidL)
dtResidW <- reshape(dtResidL, timevar = "time", idvar = "hospital_number", direction = "wide")
View(dtResidW)
str(covid)
library(readr)
csdata <- read_csv("csdata.csv")
View(csdata)
str(csdata)
dtResiL$hospital_number <- as.numeric(dtResiL$hospital_number)
dtResidL$hospital_number <- as.numeric(dtResiL$hospital_number)
dtResidL$hospital_number <- as.numeric(dtResidL$hospital_number)
dtResidL$residuals <- fit$residuals
str(dtResidL)
dtResidW <- reshape(dtResidL, timevar = "time", idvar = "hospital_number", direction = "wide")
View(dtResidW)
# Fit a fixed effects model (without controlling for random effects)
fxd <- lm(CD4 ~ period, data = csdata)
summary(fxd)
# Extract residuals
dtResidL <- subset(dtLong, select = c("id", "period"))
dtResidL$residuals <- fit$residuals
dtResidL$residuals <- fxd$residuals
dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
View(dtResidW)
dtResidW <- pivot_wider(dtResidL,
id_cols = "id", names_from = "period", values_from = residuals,
names_prefix = "resid_"
)
View(dtResidW)
# Create correlation matrices
resCor <- cor(dtResidW[, -1])
# Create a list of vectors from the matrix
listCor <- map(-(ncol(resCor) - 1):(ncol(resCor) - 1), ~ mean(resCor[outer(1:ncol(resCor), 1:ncol(resCor), "-") == .x]))
View(listCor)
View(resCor)
# Create a data frame from listCor
lag <- 1:(tp-1)
means <- unlist(listCor[1:(tp-1)])
dat2 <- data.frame(lag, means = rev(means))
# Plot line graph using the mean for each lag in the list
ggplot(dat2, aes(x = lag, y = means)) +
geom_line() +
scale_x_continuous(breaks = lag) +
ylim(c(0,1)) +
ggtitle("Compound Symmetry") +
xlab("Lag") +
ylab("Mean") +
theme_bw()
dtResidL <- subset(covid, select = c("hospital_number", "time"))
dtResidL$residuals <- fit$residuals
# dtResidW <- reshape(dtResidL, timevar = "time", idvar = "hospital_number", direction = "wide")
#
dtResidW <- pivot_wider(dtResidL,
id_cols = "hospital_number", names_from = "time", values_from = residuals,
names_prefix = "resid_"
)
View(dtResidW)
# Create correlation matrices
resCor <- cor(dtResidW[, -1])
# Create a list of vectors from the matrix
listCor <- map(-(ncol(resCor) - 1):(ncol(resCor) - 1), ~ mean(resCor[outer(1:ncol(resCor), 1:ncol(resCor), "-") == .x]))
# Create a data frame from listCor
lag <- 1:(tp-1)
means <- unlist(listCor[1:(tp-1)])
dat2 <- data.frame(lag, means = rev(means))
# Plot line graph using the mean for each lag in the list
ggplot(dat2, aes(x = lag, y = means)) +
geom_line() +
scale_x_continuous(breaks = lag) +
ylim(c(0,1)) +
ggtitle("Compound Symmetry") +
xlab("Lag") +
ylab("Mean") +
theme_bw()
# Function for ACF and PACF
plot_acf_pacf <- function(model, conf_level = 0.95) {
# Calculate residuals and ACF/PACF
residuals <- resid(model)
acf_result <- acf(residuals, plot = FALSE)
pacf_result <- pacf(residuals, plot = FALSE)
# Calculate critical lines
ciline <- qnorm((1 - conf_level) / 2) / sqrt(length(residuals))
# Create ACF plot
acf_df <- data.frame(lag = acf_result$lag, acf = acf_result$acf)
acf_plot <- ggplot(data = acf_df, aes(x = lag, y = acf)) +
geom_hline(aes(yintercept = 0)) +
geom_segment(mapping = aes(xend = lag, yend = 0)) +
geom_hline(aes(yintercept = ciline), linetype = 2, color = "blue") +
geom_hline(aes(yintercept = -ciline), linetype = 2, color = "blue") +
labs(
title = "Autocorrelation Function (ACF)",
x = "Lag", y = "ACF"
) +
theme_bw()
# Create PACF plot
pacf_df <- data.frame(lag = pacf_result$lag, acf = pacf_result$acf)
pacf_plot <- ggplot(data = pacf_df, aes(x = lag, y = acf)) +
geom_hline(aes(yintercept = 0)) +
geom_segment(mapping = aes(xend = lag, yend = 0)) +
geom_hline(aes(yintercept = ciline), linetype = 2, color = "blue") +
geom_hline(aes(yintercept = -ciline), linetype = 2, color = "blue") +
labs(
title = "Partial Autocorrelation Function (PACF)",
x = "Lag", y = "PACF"
) +
theme_bw()
return(list(acf_plot = ggplotly(acf_plot, width = 425, height = 425), pacf_plot = ggplotly(pacf_plot, width = 425, height = 425)))
}
View(plot_acf_pacf)
plot_acf_pacf(fxd)
plot_acf_pacf(fit)
View(comp_sym)
runApp('~/RShiny/LMMCov/LMMCov_v002')
set.seed(1234567)
n <- 200
tp <- 7 # 7
rho <- 0.7 # 0.8
mu <- abs(rnorm(tp, 320, 50))
sigma <- 2 # 2
# define and generate the original data set
def <- defData(varname = "age", dist = "normal", formula = 32.7, variance = 9.6, id = "id")
def <- defData(def, varname = "gender", dist = "binary", formula = 0.6)
def <- defData(def, varname = "weight", dist = "normal", formula = 50, variance = 8.6, id = "id")
def <- defData(def, varname = "marital_status", formula = "0.1;0.3;0.4;0.2", dist = "categorical", id = "id")
def <- defData(def, varname = "WHO_stage", formula = "0.2;0.15;0.55;0.1", dist = "categorical", id = "id")
dt <- genData(n, def)
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- addCorData(dt, idname = "id", mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(dtWide)
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "CD4")
dtLong <- subset(dtLong, select = -timeID)
write.csv(dtLong, file = "csdata.csv")
runApp('~/RShiny/LMMCov/LMMCov_v002')
library(simstudy)
library(psych)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(purrr)
library(Matrix)
library(MASS)
library(nlme)
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
set.seed(1234567)
n <- 200
tp <- 7 # 7
rho <- 0.7 # 0.8
mu <- abs(rnorm(tp, 320, 50))
sigma <- 10 # 2
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
# Generate CS correlation matrix for time points
comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- genCorData(n, mu = mu, sigma = sigma, corMatrix = comp_sym, cnames = cnames)
View(dtWide)
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "CD4")
dtLong <- subset(dtLong, select = -timeID)
View(dtLong)
write.csv(dtLong, file = "csdata.csv")
runApp('~/RShiny/LMMCov/LMMCov_v002')
library(readr)
csdata <- read_csv("csdata.csv")
View(csdata)
# Fit a fixed effects model (without controlling for random effects)
fxd <- lm(CD4 ~ period, data = csdata)
summary(fxd)
# Extract residuals
# dtResidL <- subset(dtLong, select = c("id", "period"))
# dtResidL$residuals <- fxd$residuals
# dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
#
library(tidyr)
dtResidW <- pivot_wider(dtResidL,
id_cols = "id", names_from = "period", values_from = residuals,
names_prefix = "resid_"
)
# Extract residuals
dtResidL <- subset(dtLong, select = c("id", "period"))
dtResidL$residuals <- fxd$residuals
dtResidW <- reshape(dtResidL, timevar = "period", idvar = "id", direction = "wide")
# Extract residuals
dtResidL <- subset(dtLong, select = c("id", "period"))
dtResidL$residuals <- fxd$residuals
library(tidyr)
dtResidW <- pivot_wider(dtResidL,
id_cols = "id", names_from = "period", values_from = residuals,
names_prefix = "resid_"
)
View(dtResidL)
View(dtResidW)
# Create correlation matrices
resCor <- cor(dtResidW[, -1])
# Create a list of vectors from the matrix
listCor <- map(-(ncol(resCor) - 1):(ncol(resCor) - 1), ~ mean(resCor[outer(1:ncol(resCor), 1:ncol(resCor), "-") == .x]))
# Create a data frame from listCor
lag <- 1:(tp-1)
means <- unlist(listCor[1:(tp-1)])
dat2 <- data.frame(lag, means = rev(means))
# Plot line graph using the mean for each lag in the list
ggplot(dat2, aes(x = lag, y = means)) +
geom_line() +
scale_x_continuous(breaks = lag) +
ylim(c(0,1)) +
ggtitle("Compound Symmetry") +
xlab("Lag") +
ylab("Mean") +
theme_bw()
# Function for ACF and PACF
plot_acf_pacf <- function(model, conf_level = 0.95) {
# Calculate residuals and ACF/PACF
residuals <- resid(model)
acf_result <- acf(residuals, plot = FALSE)
pacf_result <- pacf(residuals, plot = FALSE)
# Calculate critical lines
ciline <- qnorm((1 - conf_level) / 2) / sqrt(length(residuals))
# Create ACF plot
acf_df <- data.frame(lag = acf_result$lag, acf = acf_result$acf)
acf_plot <- ggplot(data = acf_df, aes(x = lag, y = acf)) +
geom_hline(aes(yintercept = 0)) +
geom_segment(mapping = aes(xend = lag, yend = 0)) +
geom_hline(aes(yintercept = ciline), linetype = 2, color = "blue") +
geom_hline(aes(yintercept = -ciline), linetype = 2, color = "blue") +
labs(
title = "Autocorrelation Function (ACF)",
x = "Lag", y = "ACF"
) +
theme_bw()
# Create PACF plot
pacf_df <- data.frame(lag = pacf_result$lag, acf = pacf_result$acf)
pacf_plot <- ggplot(data = pacf_df, aes(x = lag, y = acf)) +
geom_hline(aes(yintercept = 0)) +
geom_segment(mapping = aes(xend = lag, yend = 0)) +
geom_hline(aes(yintercept = ciline), linetype = 2, color = "blue") +
geom_hline(aes(yintercept = -ciline), linetype = 2, color = "blue") +
labs(
title = "Partial Autocorrelation Function (PACF)",
x = "Lag", y = "PACF"
) +
theme_bw()
return(list(acf_plot = ggplotly(acf_plot, width = 425, height = 425), pacf_plot = ggplotly(pacf_plot, width = 425, height = 425)))
}
plot_acf_pacf(fxd)
set.seed(1234567)
n <- 200
tp <- 7 # 7
rho <- 0.7 # 0.8
mu <- abs(rnorm(tp, 320, 50))
sigma <- 10 # 2
# Generate column names based on tp (time points) value
cnames <- paste0("CD4", 0:(tp - 1))
# Generate CS correlation matrix for time points
# comp_sym <- diag(1, tp) + rho * (1 - diag(1, tp))
dtWide <- genCorData(n, mu = mu, sigma = sigma, rho = rho, corstr = "cs", cnames = cnames)
View(dtWide)
# The data in longitudinal form is created with a call to addPeriods.
# The number of periods nPeriods must be the same as the number of time dependent columns
dtLong <- addPeriods(dtWide, nPeriods = tp, idvars = "id", timevars = cnames, timevarName = "CD4")
dtLong <- subset(dtLong, select = -timeID)
View(dtLong)
write.csv(dtLong, file = "csdata.csv")
runApp('~/RShiny/LMMCov/LMMCov_v002')
runApp('~/RShiny/LMMCov/LMMCov_v002')
View(csdata)
# Calculate ACF and PACF directly from raw CD4 data
acf(csdata$CD4, main = "ACF of CD4 Counts")
pacf(csdata$CD4, main = "PACF of CD4 Counts")
blogdown:::preview_site()
blogdown::serve_site()
blogdown:::preview_site()
load("~/Statistical Consultancy/Liza De Dobbeleer _ FORTO 2_0/gw.ls/gw.final.UZB_from_sid4to_sid125.rdata")
View(gw.final.UZB)
load("~/Statistical Consultancy/Liza De Dobbeleer _ FORTO 2_0/gw.ls/gw.final.UZB_from_sid126to_sid126.rdata")
load("~/Statistical Consultancy/Liza De Dobbeleer _ FORTO 2_0/gw.ls/gw.ls_UZB_from_sid4to_sid125.rdata")
View(gw.ls.UZB)
library(tidyverse)
gw.ls.UZB.s=gw.ls.UZB|>
mutate(ratioFR=FR/FR_reported)|>
arrange(ratioFR)|>
mutate(ratioFR.c=case_when(ratioFR<0.2~"0.2",
ratioFR>=0.2&ratioFR<0.8~"0.8",
ratioFR>=0.8&ratioFR<1.2~"1.2",
ratioFR>=1.2&ratioFR<2.0~"2.0",
ratioFR>=2.0~">2.0"))|>
select(sid,i_rep,ratioFR,ratioFR.c,FR_reported,FR,GW_i.f,GW_reported,MaxGS_overall)|>
arrange(ratioFR)
freq(gw.ls.UZB.s$ratioFR.c)
library(caret)
freq(gw.ls.UZB.s$ratioFR.c)
library(car)
freq(gw.ls.UZB.s$ratioFR.c)
#install.packages("questionr")
library(questionr)
#install.packages("tidyverse")
library(jsonlite)
library(tidyverse)
#install.packages("rjson")
library(rjson)
#install.packages("questionr")
library(questionr)
#install.packages("pracma")
library(pracma)
library(foreign)
freq(gw.ls.UZB.s$ratioFR.c)
h=ggplot(data=gw.ls.UZB.s,aes(x=ratioFR))
h+geom_histogram()
summary(gw.ls.UZB)
table(gw.ls.UZB$device, gw.ls.UZB$FR)
